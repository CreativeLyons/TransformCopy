--- a/source/TransformCopy.cpp
+++ b/source/TransformCopy.cpp
@@ -122,7 +122,7 @@ class TransformCopy final : public DD::Image::Transform
     const char* Class() const override { return d.name; }
     const char* node_help() const override { return kHelp; }
     int maximum_inputs() const override { return 2; }
-    int minimum_inputs() const override { return 1; }  // Input 1 (transform) is optional
+    int minimum_inputs() const override { return 2; }  // Always show 2 inputs (input 1 is optional but visible)

     void append(DD::Image::Hash& hash) override
     {
@@ -225,11 +225,18 @@ class TransformCopy final : public DD::Image::Transform

     bool test_input(int input, DD::Image::Op *op) const override
     {
 	if (input==1)
 	{
-	    // Allow input 1 to be optional (null or default_input)
-	    if (op == nullptr || op == default_input(1))
+	    // Allow input 1 to be optional (null or default/unconnected)
+	    // When unconnected, op will be nullptr or the default_input
+	    if (op == nullptr)
+	    {
+		return true;  // Unconnected is allowed
+	    }
+	    // Check if it's the default input (unconnected state)
+	    // default_input(1) returns the default input for slot 1
+	    if (op == default_input(1))
 	    {
-		return true;
+		return true;  // Default/unconnected input is allowed
 	    }
-	    // Otherwise enforce type constraint
+	    // Otherwise enforce type constraint for connected inputs
 	    return
-		(dynamic_cast<DD::Image::Transform*>(op) != nullptr) ||
-		(dynamic_cast<DD::Image::CameraOp*>(op)  != nullptr);
+		(dynamic_cast<DD::Image::Transform*>(op) != nullptr) ||
+		(dynamic_cast<DD::Image::CameraOp*>(op)  != nullptr);
 	}
 	return DD::Image::Transform::test_input(input, op);
     }
@@ -305,12 +312,18 @@ class TransformCopy final : public DD::Image::Transform

     void set_transformation_data()
     {
         bboxOut.clear();
         transformCopyOp = this;
         transformOp = nullptr;
         cameraOp = nullptr;

         if (input(0)) input(0)->validate();
-        if (input(1)) input(1)->validate();
+
+        // Early return if input 1 is not connected (optional input)
+        if (input(1) == nullptr)
+        {
+            return;
+        }
+
+        input(1)->validate();

         DD::Image::Op* node = input(1);
